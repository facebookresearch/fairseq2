<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Design Philosophy &#8212; fairseq2 0.3.0.dev202411110149+g0e6f548 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=f6bd8450" />
    <script src="../_static/documentation_options.js?v=802d06a0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Assets" href="assets.html" />
    <link rel="prev" title="Using fairseq2" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="design-philosophy">
<h1>Design Philosophy<a class="headerlink" href="#design-philosophy" title="Link to this heading">¶</a></h1>
<p>One of the core goals of fairseq2 is to make it possible for researchers to
explore new ideas and implement novel features without having to fork fairseq2.
Instead of having a monolithic repository that can only be modified by
copy-pasting large chunks of code, in fairseq2, all major APIs follow the
interface/implementation convention along with the <a class="reference external" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">dependency inversion principle</a>.
This means, each API has an <em>interface</em> (i.e. an abstract <a class="reference external" href="https://docs.python.org/3/library/abc.html#abc.ABC" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a>
class) that defines the contract of that API, and one or more concrete
implementations of that interface. Different implementations can be integrated
with the rest of fairseq2 via its lightweight <a class="reference external" href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection API</a>.</p>
<section id="interface-implementation-convention">
<h2>Interface/Implementation Convention<a class="headerlink" href="#interface-implementation-convention" title="Link to this heading">¶</a></h2>
<p>The diagram below shows the <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html"><span class="doc">position encoder API</span></a>
as an example. The API is defined by the abstract <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.PositionEncoder" title="fairseq2.nn.PositionEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PositionEncoder</span></code></a>
PyTorch module. <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.SinusoidalPositionEncoder" title="fairseq2.nn.SinusoidalPositionEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinusoidalPositionEncoder</span></code></a>, <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.LearnedPositionEncoder" title="fairseq2.nn.LearnedPositionEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LearnedPositionEncoder</span></code></a>,
and <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.RotaryEncoder" title="fairseq2.nn.RotaryEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotaryEncoder</span></code></a> implement <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.PositionEncoder" title="fairseq2.nn.PositionEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PositionEncoder</span></code></a> for their
respective algorithms. Technically, any of these position encoders can be used
wherever a <a class="reference internal" href="../reference/fairseq2.nn/position_encoders.html#fairseq2.nn.PositionEncoder" title="fairseq2.nn.PositionEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PositionEncoder</span></code></a> is expected (see <a class="reference internal" href="#dependency-inversion">Dependency Inversion</a>
below).</p>
<a class="reference internal image-reference" href="../_images/position_encoder.svg"><img alt="Position Encoder Hierarchy" class="align-center" src="../_images/position_encoder.svg" style="width: 580px;" />
</a>
<p>When several implementations of an API share common logic, a typical pattern is
to have an intermediate abstract class, prefixed with <code class="docutils literal notranslate"><span class="pre">Abstract</span></code>,  between the
interface and the concrete implementations.  For example, the <a class="reference internal" href="../reference/fairseq2.data.text/text_tokenizers.html"><span class="doc">text tokenizer
API</span></a> has <code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractTextTokenizer</span></code>
that holds the common logic for <code class="xref py py-class docutils literal notranslate"><span class="pre">SentencePieceTokenizer</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">TiktokenTokenizer</span></code>.</p>
<a class="reference internal image-reference" href="../_images/text_tokenizer.svg"><img alt="Text Tokenizer Hierarchy" class="align-center" src="../_images/text_tokenizer.svg" style="width: 580px;" />
</a>
</section>
<section id="dependency-inversion">
<h2>Dependency Inversion<a class="headerlink" href="#dependency-inversion" title="Link to this heading">¶</a></h2>
<p>The dependency inversion principle is critical to have a clean, well-tested, and
extensible API. The example below shows the (abbreviated) <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method
of the <code class="xref py py-class docutils literal notranslate"><span class="pre">StandardTransformerDecoderLayer</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StandardTransformerDecoderLayer</span><span class="p">(</span><span class="n">TransformerDecoderLayer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">self_attn</span><span class="p">:</span> <span class="n">MultiheadAttention</span><span class="p">,</span>
        <span class="n">encoder_decoder_attn</span><span class="p">:</span> <span class="n">MultiheadAttention</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ffn</span><span class="p">:</span> <span class="n">FeedForwardNetwork</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Instead of constructing the multihead attention and feed-forward network layers
within its <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method, <code class="xref py py-class docutils literal notranslate"><span class="pre">StandardTransformerDecoderLayer</span></code>
expects the caller to provide instances of <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiheadAttention</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">FeedForwardNetwork</span></code> interfaces. This loose-coupling between an instance
and its dependencies enables composing diverse object graphs, such as different
model architectures, with minimal redundancy (i.e. code duplication).</p>
</section>
<section id="dependency-injection">
<h2>Dependency Injection<a class="headerlink" href="#dependency-injection" title="Link to this heading">¶</a></h2>
<p>With dependency inversion, instead of constructing their dependencies, objects
rely on their callers to provide them. This effectively requires callers to
build a dependency graph to construct objects. For simple objects, this does not
pose a problem, but for objects with large dependency closures, manual graph
construction can become a tedious task.</p>
<p>fairseq2 offers a lightweight <a class="reference internal" href="../reference/fairseq2.dependency.html#module-fairseq2.dependency" title="fairseq2.dependency"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dependency</span> <span class="pre">injection</span> <span class="pre">API</span></code></a>
to reduce the complexity of building dependency graphs. The core piece of the
API is the <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer" title="fairseq2.dependency.DependencyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">DependencyContainer</span></code></a> interface. An implementation of it, such
as <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.StandardDependencyContainer" title="fairseq2.dependency.StandardDependencyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardDependencyContainer</span></code></a>, is expected that hold a lazily-initialized
dependency graph. The interface exposes two main methods; <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code>. <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a>
is used to register new objects with the container and <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve" title="fairseq2.dependency.DependencyResolver.resolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a>
is used to <em>resolve</em> objects, meaning to create objects along with their
transitive dependencies by traversing the graph.</p>
<section id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Link to this heading">¶</a></h3>
<p>The example below shows how an object of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> can be registered and
later resolved with a container:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">DependencyResolver</span><span class="p">,</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">create_foo</span><span class="p">(</span><span class="n">resolver</span><span class="p">:</span> <span class="n">DependencyResolver</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Foo</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_factory</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">create_foo</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p>As arguments, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a> expects the type of the
object and a callable responsible for creating the object when called. The
callable is passed a <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver" title="fairseq2.dependency.DependencyResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">DependencyResolver</span></code></a> instance that it can use to
resolve the dependencies of the newly-created object. The object returned by the
callable is cached. This means, after the first <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve" title="fairseq2.dependency.DependencyResolver.resolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a>
call, the secondary calls will return the same instance making the object
effectively a singleton.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">Foo</span></code> is a lightweight class with no dependencies, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_instance" title="fairseq2.dependency.DependencyContainer.register_instance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_instance()</span></code></a>
can be used instead of <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a>. Unlike
<a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a>, which expects a callable to lazily
initialize the object, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_instance" title="fairseq2.dependency.DependencyContainer.register_instance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_instance()</span></code></a> stores the
passed object directly in the container:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Foo</span><span class="p">())</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p>Both <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a> and <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_instance" title="fairseq2.dependency.DependencyContainer.register_instance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_instance()</span></code></a>
also accept an optional key argument. When provided, the object will be
registered along with the key and will be resolved only when the same key is
passed to <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve" title="fairseq2.dependency.DependencyResolver.resolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve" title="fairseq2.dependency.DependencyResolver.resolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a> will raise a <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyError" title="fairseq2.dependency.DependencyError"><code class="xref py py-class docutils literal notranslate"><span class="pre">DependencyError</span></code></a> when an
object cannot be found. As an alternative, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve_optional" title="fairseq2.dependency.DependencyResolver.resolve_optional"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve_optional()</span></code></a>
can be used which returns <code class="docutils literal notranslate"><span class="pre">None</span></code> instead:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve_optional</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="registering-multiple-objects">
<h3>Registering Multiple Objects<a class="headerlink" href="#registering-multiple-objects" title="Link to this heading">¶</a></h3>
<p>When <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_factory" title="fairseq2.dependency.DependencyContainer.register_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_factory()</span></code></a> or <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyContainer.register_instance" title="fairseq2.dependency.DependencyContainer.register_instance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_instance()</span></code></a>
is called multiple times with the same type and, optionally, key,
<a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve" title="fairseq2.dependency.DependencyResolver.resolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a> will return only the last registered object:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo1</span><span class="p">)</span>
<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo2</span><span class="p">)</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">foo2</span>
</pre></div>
</div>
<p>If, not just the last registered object, but all registered objects of certain
type are needed, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve_all" title="fairseq2.dependency.DependencyResolver.resolve_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve_all()</span></code></a> can be used. It returns
all non-keyed objects in the order they were registered as an iterable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo1</span><span class="p">)</span>
<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo2</span><span class="p">)</span>

<span class="n">itr</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve_all</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span> <span class="ow">is</span> <span class="n">foo1</span>
<span class="k">assert</span> <span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span> <span class="ow">is</span> <span class="n">foo2</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve_all_keyed" title="fairseq2.dependency.DependencyResolver.resolve_all_keyed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve_all_keyed()</span></code></a> is similar to <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.DependencyResolver.resolve_all" title="fairseq2.dependency.DependencyResolver.resolve_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve_all()</span></code></a>,
but works for keyed objects. It returns them as key-object pairs in the order
they were registered as an iterable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">foo1</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">()</span>

<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;foo1&quot;</span><span class="p">)</span>
<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">foo2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;foo2&quot;</span><span class="p">)</span>

<span class="n">itr</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve_all</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">obj1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span>
<span class="n">key2</span><span class="p">,</span> <span class="n">obj2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">key1</span> <span class="o">==</span> <span class="s2">&quot;foo1&quot;</span>
<span class="k">assert</span> <span class="n">key2</span> <span class="o">==</span> <span class="s2">&quot;foo2&quot;</span>

<span class="k">assert</span> <span class="n">obj1</span> <span class="ow">is</span> <span class="n">foo1</span>
<span class="k">assert</span> <span class="n">obj2</span> <span class="ow">is</span> <span class="n">foo2</span>
</pre></div>
</div>
</section>
</section>
<section id="a-more-complete-example">
<h2>A More Complete Example<a class="headerlink" href="#a-more-complete-example" title="Link to this heading">¶</a></h2>
<p>The example below is slightly more complex and shows how an object with a
dependency can be registered to the container. It also demonstrates the use of
interfaces as registration types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">StandardDependencyContainer</span>

<span class="n">container</span> <span class="o">=</span> <span class="n">StandardDependencyContainer</span><span class="p">()</span>

<span class="c1"># `Writer` Interface</span>
<span class="k">class</span> <span class="nc">Writer</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># `Writer` Implementation</span>
<span class="k">class</span> <span class="nc">StdOutWriter</span><span class="p">(</span><span class="n">Bar</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># `Foo` Interface</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">write_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># `Foo` Implementation</span>
<span class="k">class</span> <span class="nc">FooImpl</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span>
    <span class="c1"># depends on a `Writer` instance.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="p">:</span> <span class="n">Writer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="n">writer</span>

    <span class="k">def</span> <span class="nf">write_foo</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Registers `Writer`.</span>
<span class="n">container</span><span class="o">.</span><span class="n">register_instance</span><span class="p">(</span><span class="n">Writer</span><span class="p">,</span> <span class="n">StdOutWriter</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">create_foo</span><span class="p">(</span><span class="n">resolver</span><span class="p">:</span> <span class="n">DependencyResolver</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Foo</span><span class="p">:</span>
    <span class="c1"># Resolves the registered `Writer` object from the container.</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">resolver</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Writer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">FooImpl</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>

<span class="c1"># Registers `Foo`.</span>
<span class="n">container</span><span class="o">.</span><span class="n">register_factory</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="n">create_foo</span><span class="p">)</span>

<span class="c1"># Internally calls `create_foo` to create the `Foo` instance.</span>
<span class="n">foo1</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">foo1</span> <span class="ow">is</span> <span class="n">FooImpl</span>

<span class="c1"># Prints &quot;FooImpl&quot; to stdout.</span>
<span class="n">foo1</span><span class="o">.</span><span class="n">write_foo</span><span class="p">()</span>

<span class="c1"># Secondary calls return the same object.</span>
<span class="n">foo2</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">foo1</span> <span class="ow">is</span> <span class="n">foo2</span>
</pre></div>
</div>
<section id="using-fairseq2-container">
<h3>Using fairseq2 Container<a class="headerlink" href="#using-fairseq2-container" title="Link to this heading">¶</a></h3>
<p>The examples above all used a newly-created <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.StandardDependencyContainer" title="fairseq2.dependency.StandardDependencyContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardDependencyContainer</span></code></a>
for demonstration purposes. In real-world, objects are typically registered with
fairseq2’s global container. There are two ways to access it:</p>
<ul class="simple">
<li><p>For a Python package, an extension function can be used to make the objects of
the package available to all fairseq2 users.  See <a class="reference internal" href="runtime_extensions.html"><span class="doc">Runtime Extensions</span></a>
for details.</p></li>
<li><p>In a plain Python script, <a class="reference internal" href="../reference/fairseq2.dependency.html#fairseq2.dependency.get_container" title="fairseq2.dependency.get_container"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_container()</span></code></a> can be used. <a class="reference internal" href="../reference/fairseq2.html#fairseq2.setup_fairseq2" title="fairseq2.setup_fairseq2"><code class="xref py py-func docutils literal notranslate"><span class="pre">setup_fairseq2()</span></code></a>
has to be called first though which is responsible for initializing the global
container.</p></li>
</ul>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fairseq2</span> <span class="kn">import</span> <span class="n">setup_fairseq2</span>
<span class="kn">from</span> <span class="nn">fairseq2.assets</span> <span class="kn">import</span> <span class="n">AssetStore</span>
<span class="kn">from</span> <span class="nn">fairseq2.dependency</span> <span class="kn">import</span> <span class="n">get_container</span>

<span class="c1"># Must be called before any other fairseq2 calls.</span>
<span class="n">setup_fairseq2</span><span class="p">()</span>

<span class="c1"># Returns the global `DependencyContainer` initialized by `setup_fairseq2`.</span>
<span class="n">container</span> <span class="o">=</span> <span class="n">get_container</span><span class="p">()</span>

<span class="c1"># Resolves the registered `AssetStore` object, which is by default an</span>
<span class="c1"># instance of `StandardAssetStore`.</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">AssetStore</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">fairseq2</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Using fairseq2</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Design Philosophy</a></li>
<li class="toctree-l2"><a class="reference internal" href="assets.html">Assets</a></li>
<li class="toctree-l2"><a class="reference internal" href="data_pipelines.html">Data Pipelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime_extensions.html">Runtime Extensions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Using fairseq2</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Using fairseq2</a></li>
      <li>Next: <a href="assets.html" title="next chapter">Assets</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
      
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/topics/design_philosophy.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>